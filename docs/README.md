# 《LeetCode/剑指offer》

[<img src="https://img.shields.io/badge/%E7%A4%BA%E4%BE%8B-%E6%AC%A2%E8%BF%8E%E8%AE%BF%E9%97%AE-important">](https://github.com/glong1997)

> 《LeetCode/剑指offer》

## 导航

- [时间复杂度](#时间复杂度)
- [空间复杂度](#空间复杂度)
- [二叉树](#二叉树)
- [回溯](#回溯)
- [动态规划](#动态规划)



## 时间复杂度



## 空间复杂度



## 二叉树

```markdown
# 满二叉树

# 完全二叉树：底部一定是从左到右连续的。满二叉树一定是完全二叉树。

# 二叉搜索树

# 平衡二叉搜索树：左子树和右子树高度差不能超过1。
```

二叉树使用的是链式存储，可以理解为链表，只不过有两个指针，一个指向左孩子，一个指向右孩子。

### 深度优先搜索

前序、中序、后序遍历都是`深度优先搜索`，沿着一个方向一直搜索。一般使用递归实现。

### 广度优先搜索

层序遍历

## 回溯

两者是相辅相成，可以用于解决

```markdown
1. 组合问题
2. 切割问题
3. 子集问题
4. 排列问题：与组合相比，更强调元素的顺序
5. 棋盘问题
```

所有回溯都可抽象为树形结构。

回溯一定是递归问题，而递归一定是终止的。

for循环就是树的宽度，递归就是树的深度。

回溯算法一般是没有返回值的。`通用模板`为：

```java
void backtracking(参数){
		if(终止条件) 叶子结点收集结果 return;
		
		for(集合元素){
				处理结点;
        递归函数;
      	回溯撤销操作;	// 组合问题的撤销操作：(1, 2) -> (1, ) -> (1, 3)，如果没有撤销就是（1，2，3）
		}
}
```

## 动态规划
